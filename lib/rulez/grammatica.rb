# Autogenerated from a Treetop grammar. Edits may be lost.


module Rulez
  include Treetop::Runtime

  def root
    @root ||= :root
  end

  def _nt_root
    start_index = index
    if node_cache[:root].has_key?(index)
      cached = node_cache[:root][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_ruleor

    node_cache[:root][start_index] = r0

    r0
  end

  module Ruleor0
    def OR
      elements[0]
    end

    def ruleand
      elements[1]
    end
  end

  module Ruleor1
    def ruleand
      elements[0]
    end

  end

  def _nt_ruleor
    start_index = index
    if node_cache[:ruleor].has_key?(index)
      cached = node_cache[:ruleor][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ruleand
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_OR
        s3 << r4
        if r4
          r5 = _nt_ruleand
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Ruleor0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Ruleor1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ruleor][start_index] = r0

    r0
  end

  module Ruleand0
    def AND
      elements[0]
    end

    def rulecmp
      elements[1]
    end
  end

  module Ruleand1
    def rulecmp
      elements[0]
    end

  end

  def _nt_ruleand
    start_index = index
    if node_cache[:ruleand].has_key?(index)
      cached = node_cache[:ruleand][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_rulecmp
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_AND
        s3 << r4
        if r4
          r5 = _nt_rulecmp
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(Ruleand0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Ruleand1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ruleand][start_index] = r0

    r0
  end

  module Rulecmp0
    def LTE
      elements[0]
    end

    def ruleadd
      elements[1]
    end
  end

  module Rulecmp1
    def GTE
      elements[0]
    end

    def ruleadd
      elements[1]
    end
  end

  module Rulecmp2
    def GT
      elements[0]
    end

    def ruleadd
      elements[1]
    end
  end

  module Rulecmp3
    def LT
      elements[0]
    end

    def ruleadd
      elements[1]
    end
  end

  module Rulecmp4
    def EQ
      elements[0]
    end

    def ruleadd
      elements[1]
    end
  end

  module Rulecmp5
    def NEQ
      elements[0]
    end

    def ruleadd
      elements[1]
    end
  end

  module Rulecmp6
    def ruleadd
      elements[0]
    end

  end

  def _nt_rulecmp
    start_index = index
    if node_cache[:rulecmp].has_key?(index)
      cached = node_cache[:rulecmp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ruleadd
    s0 << r1
    if r1
      i3 = index
      i4, s4 = index, []
      r5 = _nt_LTE
      s4 << r5
      if r5
        r6 = _nt_ruleadd
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(Rulecmp0)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r3 = r4
      else
        i7, s7 = index, []
        r8 = _nt_GTE
        s7 << r8
        if r8
          r9 = _nt_ruleadd
          s7 << r9
        end
        if s7.last
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          r7.extend(Rulecmp1)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r3 = r7
        else
          i10, s10 = index, []
          r11 = _nt_GT
          s10 << r11
          if r11
            r12 = _nt_ruleadd
            s10 << r12
          end
          if s10.last
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
            r10.extend(Rulecmp2)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r3 = r10
          else
            i13, s13 = index, []
            r14 = _nt_LT
            s13 << r14
            if r14
              r15 = _nt_ruleadd
              s13 << r15
            end
            if s13.last
              r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
              r13.extend(Rulecmp3)
            else
              @index = i13
              r13 = nil
            end
            if r13
              r3 = r13
            else
              i16, s16 = index, []
              r17 = _nt_EQ
              s16 << r17
              if r17
                r18 = _nt_ruleadd
                s16 << r18
              end
              if s16.last
                r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                r16.extend(Rulecmp4)
              else
                @index = i16
                r16 = nil
              end
              if r16
                r3 = r16
              else
                i19, s19 = index, []
                r20 = _nt_NEQ
                s19 << r20
                if r20
                  r21 = _nt_ruleadd
                  s19 << r21
                end
                if s19.last
                  r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                  r19.extend(Rulecmp5)
                else
                  @index = i19
                  r19 = nil
                end
                if r19
                  r3 = r19
                else
                  @index = i3
                  r3 = nil
                end
              end
            end
          end
        end
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Rulecmp6)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rulecmp][start_index] = r0

    r0
  end

  module Ruleadd0
    def PLUS
      elements[0]
    end

    def rulemult
      elements[1]
    end
  end

  module Ruleadd1
    def MINUS
      elements[0]
    end

    def rulemult
      elements[1]
    end
  end

  module Ruleadd2
    def rulemult
      elements[0]
    end

  end

  def _nt_ruleadd
    start_index = index
    if node_cache[:ruleadd].has_key?(index)
      cached = node_cache[:ruleadd][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_rulemult
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        i4, s4 = index, []
        r5 = _nt_PLUS
        s4 << r5
        if r5
          r6 = _nt_rulemult
          s4 << r6
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(Ruleadd0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          r3 = r4
        else
          i7, s7 = index, []
          r8 = _nt_MINUS
          s7 << r8
          if r8
            r9 = _nt_rulemult
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(Ruleadd1)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r3 = r7
          else
            @index = i3
            r3 = nil
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Ruleadd2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ruleadd][start_index] = r0

    r0
  end

  module Rulemult0
    def MUL
      elements[0]
    end

    def ruleunary
      elements[1]
    end
  end

  module Rulemult1
    def DIV
      elements[0]
    end

    def ruleunary
      elements[1]
    end
  end

  module Rulemult2
    def ruleunary
      elements[0]
    end

  end

  def _nt_rulemult
    start_index = index
    if node_cache[:rulemult].has_key?(index)
      cached = node_cache[:rulemult][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ruleunary
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        i4, s4 = index, []
        r5 = _nt_MUL
        s4 << r5
        if r5
          r6 = _nt_ruleunary
          s4 << r6
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(Rulemult0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          r3 = r4
        else
          i7, s7 = index, []
          r8 = _nt_DIV
          s7 << r8
          if r8
            r9 = _nt_ruleunary
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(Rulemult1)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r3 = r7
          else
            @index = i3
            r3 = nil
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Rulemult2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rulemult][start_index] = r0

    r0
  end

  module Ruleunary0
    def MINUS
      elements[0]
    end

    def primary
      elements[1]
    end
  end

  module Ruleunary1
    def NOT
      elements[0]
    end

    def primary
      elements[1]
    end
  end

  def _nt_ruleunary
    start_index = index
    if node_cache[:ruleunary].has_key?(index)
      cached = node_cache[:ruleunary][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_MINUS
    s1 << r2
    if r2
      r3 = _nt_primary
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Ruleunary0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_NOT
      s4 << r5
      if r5
        r6 = _nt_primary
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(Ruleunary1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        r7 = _nt_primary
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:ruleunary][start_index] = r0

    r0
  end

  module Primary0
    def RO
      elements[0]
    end

    def ruleor
      elements[1]
    end

    def RC
      elements[2]
    end
  end

  def _nt_primary
    start_index = index
    if node_cache[:primary].has_key?(index)
      cached = node_cache[:primary][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_RO
    s1 << r2
    if r2
      r3 = _nt_ruleor
      s1 << r3
      if r3
        r4 = _nt_RC
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Primary0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt_BOOL
      if r5
        r0 = r5
      else
        r6 = _nt_NUM
        if r6
          r0 = r6
        else
          r7 = _nt_SYMBOL
          if r7
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:primary][start_index] = r0

    r0
  end

  def _nt_OR
    start_index = index
    if node_cache[:OR].has_key?(index)
      cached = node_cache[:OR][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('||', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('||')
      r0 = nil
    end

    node_cache[:OR][start_index] = r0

    r0
  end

  def _nt_AND
    start_index = index
    if node_cache[:AND].has_key?(index)
      cached = node_cache[:AND][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('&&', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('&&')
      r0 = nil
    end

    node_cache[:AND][start_index] = r0

    r0
  end

  def _nt_LTE
    start_index = index
    if node_cache[:LTE].has_key?(index)
      cached = node_cache[:LTE][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('<=', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('<=')
      r0 = nil
    end

    node_cache[:LTE][start_index] = r0

    r0
  end

  def _nt_GTE
    start_index = index
    if node_cache[:GTE].has_key?(index)
      cached = node_cache[:GTE][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('>=', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('>=')
      r0 = nil
    end

    node_cache[:GTE][start_index] = r0

    r0
  end

  def _nt_GT
    start_index = index
    if node_cache[:GT].has_key?(index)
      cached = node_cache[:GT][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('>', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('>')
      r0 = nil
    end

    node_cache[:GT][start_index] = r0

    r0
  end

  def _nt_LT
    start_index = index
    if node_cache[:LT].has_key?(index)
      cached = node_cache[:LT][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('<', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('<')
      r0 = nil
    end

    node_cache[:LT][start_index] = r0

    r0
  end

  def _nt_EQ
    start_index = index
    if node_cache[:EQ].has_key?(index)
      cached = node_cache[:EQ][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('==', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('==')
      r0 = nil
    end

    node_cache[:EQ][start_index] = r0

    r0
  end

  def _nt_NEQ
    start_index = index
    if node_cache[:NEQ].has_key?(index)
      cached = node_cache[:NEQ][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('!=', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure('!=')
      r0 = nil
    end

    node_cache[:NEQ][start_index] = r0

    r0
  end

  def _nt_PLUS
    start_index = index
    if node_cache[:PLUS].has_key?(index)
      cached = node_cache[:PLUS][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('+', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('+')
      r0 = nil
    end

    node_cache[:PLUS][start_index] = r0

    r0
  end

  def _nt_MINUS
    start_index = index
    if node_cache[:MINUS].has_key?(index)
      cached = node_cache[:MINUS][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('-', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('-')
      r0 = nil
    end

    node_cache[:MINUS][start_index] = r0

    r0
  end

  def _nt_MUL
    start_index = index
    if node_cache[:MUL].has_key?(index)
      cached = node_cache[:MUL][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('*', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('*')
      r0 = nil
    end

    node_cache[:MUL][start_index] = r0

    r0
  end

  def _nt_DIV
    start_index = index
    if node_cache[:DIV].has_key?(index)
      cached = node_cache[:DIV][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('/', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('/')
      r0 = nil
    end

    node_cache[:DIV][start_index] = r0

    r0
  end

  def _nt_NOT
    start_index = index
    if node_cache[:NOT].has_key?(index)
      cached = node_cache[:NOT][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('!', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('!')
      r0 = nil
    end

    node_cache[:NOT][start_index] = r0

    r0
  end

  def _nt_RO
    start_index = index
    if node_cache[:RO].has_key?(index)
      cached = node_cache[:RO][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('(', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r0 = nil
    end

    node_cache[:RO][start_index] = r0

    r0
  end

  def _nt_RC
    start_index = index
    if node_cache[:RC].has_key?(index)
      cached = node_cache[:RC][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(')', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(')')
      r0 = nil
    end

    node_cache[:RC][start_index] = r0

    r0
  end

  module SYMBOL0
  end

  def _nt_SYMBOL
    start_index = index
    if node_cache[:SYMBOL].has_key?(index)
      cached = node_cache[:SYMBOL][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[a-zA-Z]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[a-zA-Z_0-9]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(SYMBOL0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:SYMBOL][start_index] = r0

    r0
  end

  module NUM0
  end

  def _nt_NUM
    start_index = index
    if node_cache[:NUM].has_key?(index)
      cached = node_cache[:NUM][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    s2, i2 = [], index
    loop do
      if has_terminal?('\G[0-9]', true, index)
        r3 = true
        @index += 1
      else
        r3 = nil
      end
      if r3
        s2 << r3
      else
        break
      end
    end
    if s2.empty?
      @index = i2
      r2 = nil
    else
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
    end
    s1 << r2
    if r2
      if has_terminal?('.', false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('.')
        r4 = nil
      end
      s1 << r4
      if r4
        s5, i5 = [], index
        loop do
          if has_terminal?('\G[0-9]', true, index)
            r6 = true
            @index += 1
          else
            r6 = nil
          end
          if r6
            s5 << r6
          else
            break
          end
        end
        if s5.empty?
          @index = i5
          r5 = nil
        else
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        end
        s1 << r5
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(NUM0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      s7, i7 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r8 = true
          @index += 1
        else
          r8 = nil
        end
        if r8
          s7 << r8
        else
          break
        end
      end
      if s7.empty?
        @index = i7
        r7 = nil
      else
        r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
      end
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:NUM][start_index] = r0

    r0
  end

  def _nt_BOOL
    start_index = index
    if node_cache[:BOOL].has_key?(index)
      cached = node_cache[:BOOL][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?('true', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure('true')
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?('false', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('false')
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:BOOL][start_index] = r0

    r0
  end

end

class RulezParser < Treetop::Runtime::CompiledParser
  include Rulez
end
